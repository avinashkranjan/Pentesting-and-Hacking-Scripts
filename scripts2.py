import os
import time
import hashlib
import threading

class FileMonitor:
    def __init__(self, directory):
        self.directory = directory
        self.file_sizes = {}
        self.file_hashes = {}
        self.file_last_modified = {}
        self.lock = threading.Lock()

    def start_monitoring(self):
        self.initial_scan()

        # Start the monitoring thread
        monitoring_thread = threading.Thread(target=self.monitor_files)
        monitoring_thread.daemon = True
        monitoring_thread.start()

        # Start the periodic analysis thread
        analysis_thread = threading.Thread(target=self.periodic_analysis)
        analysis_thread.daemon = True
        analysis_thread.start()

        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("Monitoring stopped.")

    def initial_scan(self):
        for root, dirs, files in os.walk(self.directory):
            for file in files:
                file_path = os.path.join(root, file)
                self.update_file_info(file_path)

    def update_file_info(self, file_path):
        file_size = os.path.getsize(file_path)
        file_hash = self.calculate_file_hash(file_path)
        current_time = time.time()

        with self.lock:
            self.file_sizes[file_path] = file_size
            self.file_hashes[file_path] = file_hash
            self.file_last_modified[file_path] = current_time

    def calculate_file_hash(self, file_path):
        hash_obj = hashlib.sha256()

        with open(file_path, 'rb') as file:
            while True:
                data = file.read(4096)
                if not data:
                    break
                hash_obj.update(data)

        return hash_obj.hexdigest()

    def monitor_files(self):
        while True:
            for root, dirs, files in os.walk(self.directory):
                for file in files:
                    file_path = os.path.join(root, file)

                    if not os.path.isfile(file_path):
                        continue

                    with self.lock:
                        if file_path in self.file_sizes:
                            current_size = os.path.getsize(file_path)
                            if current_size != self.file_sizes[file_path]:
                                self.handle_file_modification(file_path)
                        else:
                            self.update_file_info(file_path)

            time.sleep(1)

    def handle_file_modification(self, file_path):
        current_hash = self.calculate_file_hash(file_path)
        current_time = time.time()

        with self.lock:
            if current_hash != self.file_hashes[file_path]:
                time_diff = current_time - self.file_last_modified[file_path]
                if time_diff < 10:
                    self.detect_ransomware(file_path)
                else:
                    self.update_file_info(file_path)
            else:
                self.file_last_modified[file_path] = current_time

    def detect_ransomware(self, file_path):
        print(f"Potential ransomware activity detected: {file_path}")

        # Take appropriate action to mitigate the impact
        # This may include isolating the infected system, terminating processes, alerting administrators, etc.

    def periodic_analysis(self):
        while True:
            with self.lock:
                for file_path in list(self.file_hashes.keys()):
                    if not os.path.isfile(file_path):
                        del self.file_sizes[file_path]
                        del self.file_hashes[file_path]
                        del self.file_last_modified[file_path]

            time.sleep(60)

# Specify the directory to monitor for ransomware detection
directory_to_monitor = "/home/mridul/Pictures"

# Create an instance of FileMonitor and start monitoring
file_monitor = FileMonitor(directory_to_monitor)
file_monitor.start_monitoring()
